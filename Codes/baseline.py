# -*- coding: utf-8 -*-
"""baseline.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18tM9VvVtCxbmv4CpVy3aJyPxdQdTgtqP
"""

import torch
import torch.nn as nn
import torch.optim as optim
from Backbone_Resnet import RadarResNet


class HeatmapBaseline(nn.Module):
    def __init__(self, input_size=None, backbone='r18'):
        super(HeatmapBaseline, self).__init__()
        self.input_size = input_size
        self.bk = backbone
        self.stride = 4

        # Backbone
        self.backbone = nn.Sequential(*list(resnet.children())[:-2])
        self.backbone = RadarResNet(block=BasicBlock, layers=[2, 2, 2, 2])  # Adjust layers as needed

        # Neck
        self.neck = nn.Conv2d(1, 256, kernel_size=3, padding=1)

        # Upsample
        self.deconv2 = nn.ConvTranspose2d(256, 256, kernel_size=4, stride=2, padding=1)
        self.latter2 = nn.Conv2d(256, 256, kernel_size=3, padding=1)
        self.smooth2 = nn.Conv2d(256, 256, kernel_size=3, padding=1)

        # Detection head
        self.cls_pred = nn.Sequential(
            nn.Conv2d(256, 64, kernel_size=3, padding=1),
            nn.Conv2d(64, 1, kernel_size=1)  # Output a single-channel heatmap
        )



    def forward(self, x, target=None):
        # Backbone
        if self.bk == 'r18':
            print("Use backbone : resnet-18")
            self.backbone = resnet18(pretrained=trainable)
        c2, c3, c4, c5 = self.backbone(x)
        B = x.size(0)

        # Neck
        p5 = self.neck(x)

        # Upsample
        p2 = self.smooth2(self.latter2(x) + self.deconv2(p5))

        # Detection head
        cls_pred = self.cls_pred(p2)

        # Test
        with torch.no_grad():
            # Batch size = 1
            cls_pred_sigmoid = torch.sigmoid(cls_pred)

            # Visualize heatmap
            self.vis_fmap(cls_pred_sigmoid[0], normal=False, name='heatmap')

            # Compute MSE loss
            if target is not None:
                mse_loss = nn.MSELoss()
                target_heatmap = self.generate_heatmap(target)
                target_heatmap = torch.tensor(target_heatmap).view(1, 1, self.input_size, self.input_size).float()
                mse = mse_loss(cls_pred_sigmoid, target_heatmap)

                return cls_pred_sigmoid, mse

            return cls_pred_sigmoid

    def generate_heatmap(self, target):
        heatmap = torch.zeros((1, 1, self.input_size, self.input_size), dtype=torch.float32)

        center_x, center_y = target
        sigma = 2.0

        for i in range(self.input_size):
            for j in range(self.input_size):
                heatmap[0, 0, i, j] = torch.exp(-((i - center_x) ** 2 + (j - center_y) ** 2) / (2 * sigma ** 2))

        return heatmap